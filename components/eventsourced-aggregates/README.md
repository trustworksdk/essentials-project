# Essentials Components - EventSourced Aggregates

This library focuses on providing different flavours of Event Source Aggregates that are built to work with
the  [`EventStore`](../postgresql-event-store/README.md) concept.  
The `EventStore` is very flexible and doesn't specify any specific design requirements for an Aggregate or its Events,
except that that have to be associated with an `AggregateType` (see the
`AggregateType` sub section of the [`EventStore`](../postgresql-event-store/README.md) for more information).

> **NOTE:**  
> **The library is WORK-IN-PROGRESS**

# Security
In general follow the security advises for the [`EventStore`](../postgresql-event-store/README.md).

Several of the Essentials components, as well as their subcomponents and/or supporting classes, allows the user of the components to provide customized:
- table names
- column names
- etc.

By using naming conventions for Postgresql table/column/index names, Essentials attempts to provide an initial layer of defense intended to reduce the risk of malicious input.    
**However, Essentials does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL and Mongo Queries/Updates against injection threats.**
> The responsibility for implementing protective measures against malicious API input and configuration values lies  exclusively with the users/developers using the Essentials components and its supporting classes.
> Users must ensure thorough sanitization and validation of API input parameters, values, column names, function names, table names, and index names

**Insufficient attention to these practices may leave the application vulnerable to attacks, endangering the security and integrity of the database.**

It's highly recommended that customized values are only derived from a controlled and trusted source.  
**Failure on the users behalf to adequately sanitize and validate these values could expose the application to database specific vulnerabilities, such as SQL Injection or
modify unauthorized collections, all of which can compromise the security and integrity of the databases.**

## Additional Security advice for `PostgresqlAggregateSnapshotRepository`
The user can supply a custom `snapshotTableName` for the `PostgresqlAggregateSnapshotRepository`.
The `snapshotTableName` controls the name of the table where `AggregateSnapshot`'s will be stored.

The `snapshotTableName` will be directly used in constructing SQL statements through string concatenation, which exposes the component to 
SQL injection attacks.  

> It is the responsibility of the user of this component to sanitize the `snapshotTableName` to ensure the security of all the SQL statements generated by this component. 
 
The `PostgresqlAggregateSnapshotRepository` component will call the `PostgresqlUtil.checkIsValidTableOrColumnName(String)` method to validate the 
table name as a first line of defense.
The `PostgresqlUtil#checkIsValidTableOrColumnName(String)` provides an initial layer of defense against SQL injection by applying naming conventions intended to reduce the risk of malicious input.    
**However, Essentials components as well as `PostgresqlUtil#checkIsValidTableOrColumnName(String)` does not offer exhaustive protection, nor does it assure the complete security of the resulting SQL against SQL injection threats.**  
> The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.
> Users must ensure thorough sanitization and validation of API input parameters, values, column names, function names, table names, and index names

**Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.**

It is highly recommended that the snapshotTableName value is only derived from a controlled and trusted source. 

>To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the `snapshotTableName` value.

**Failure to adequately sanitize and validate this value could expose the application to SQL injection vulnerabilities, compromising the security and integrity of the database.**

# Aggregate-Id

In event sourcing, an Aggregate-Id is a unique identifier that groups together related events belonging to the same business entity (aggregate). It plays a crucial role in:

1. **Event Organization**: All events related to a specific aggregate instance share the same Aggregate-Id, allowing for easy tracking and retrieval of an aggregate's complete history.

2. **Stream Identification**: The Aggregate-Id helps identify which event stream an event belongs to, making it possible to rebuild the aggregate's state by replaying all events with the same ID.

3. **Concurrency Control**: Used to ensure that events for the same aggregate instance are processed in the correct order and to detect potential conflicts.

IMPORTANT: For security reasons, Aggregate-Id's should:

- Be generated using secure methods (e.g., `RandomIdGenerator#generate()` or `UUID#randomUUID()`)
- Never contain user-supplied input without proper validation
- Use safe characters to prevent SQL injection attacks when used in database operations that perform SQL string concatenation

# More details on Aggregate designs
This library supports multiple flavours of Aggregate design such as:

- The **modern** `dk.trustworks.essentials.components.eventsourced.aggregates.stateful.modern.AggregateRoot` **(preferred)**
  - Modern with separate state object: Have the `AggregateRoot` implement `dk.trustworks.essentials.components.eventsourced.aggregates.stateful.modern.WithState` and provide a State class that extends `AggregateState`
- The *classic* `dk.trustworks.essentials.components.eventsourced.aggregates.stateful.classic.AggregateRoot` (kept for backwards compatibility)
  - The *classic* with separate state object `dk.trustworks.essentials.components.eventsourced.aggregates.stateful.classic.state.AggregateRootWithState`
- The **functional** `dk.trustworks.essentials.components.eventsourced.aggregates.flex.FlexAggregate`
- The **Decider** pattern `dk.trustworks.essentials.components.eventsourced.aggregates.decider.Decider`
  - See `dk.trustworks.essentials.components.eventsourced.aggregates.decider.DeciderTest`
  - and `dk.trustworks.essentials.components.eventsourced.aggregates.decider.DeciderBasedCommandHandlerIT`
- The **EventStreamDecider** pattern `dk.trustworks.essentials.components.eventsourced.aggregates.eventstream.EventStreamDecider`

The **modern** `AggregateRoot`, *classic* `AggregateRoot` and *classic* `AggregateRootWithState` are all examples of a
mutable `StatefulAggregate` design.

What makes an `Aggregate` design **stateful** is the fact that any changes, i.e. Events applied as the result of calling
command methods on the aggregate instance, are stored within
the `StatefulAggregate` and can be queried using `getUncommittedChanges()` and reset (e.g. after a
transaction/UnitOfWork has completed) using `markChangesAsCommitted()`

Each aggregate loaded or being saved gets associated with the currently active `UnitOfWork`.  
When the `UnitOfWork` is in the commit phase, then the `UnitOfWork` is queries for all changed entities, and the events
stored within the `StatefulAggregate`'s
will be persisted to the `EventStore`.

The `FlexAggregate` follows a functional immutable Aggregate design where each command method returns
the `EventsToPersist` and applying events doesn't alter the state of the aggregate (only rehydration modifies the
aggregate state).

Check the `Order` and `FlexAggregateRepositoryIT` examples
in `essentials-components/eventsourced-aggregates/src/test/java/dk/trustworks/essentials/components/eventsourced/aggregates/flex`

To use `EventSourced Aggregates` just add the following Maven dependency:

```
<dependency>
    <groupId>dk.trustworks.essentials.components/groupId>
    <artifactId>eventsourced-aggregates</artifactId>
    <version>0.40.25</version>
</dependency>
```

## Choosing Between Aggregate Patterns

The EventSourced Aggregates component provides multiple patterns for different use cases and architectural preferences. Here's a comprehensive guide to help you choose:

### Decision Matrix

| **Criteria**               | **Modern AggregateRoot** | **WithState Pattern**   | **FlexAggregate**        | **Traditional Decider**  | **EventStreamDecider**             |
|----------------------------|--------------------------|-------------------------|--------------------------|--------------------------|------------------------------------|
| **Complexity**             | Simple to Moderate       | Moderate                | Moderate                 | Complex                  | Simple                             |
| **State Management**       | Internal mutable state   | External mutable state  | Internal immutable state | External immutable state | Event stream-based immutable state |
| **Testing**                | Unit tests               | Separated state testing | Functional testing       | Simple setup             | Simple using Given-When-Then       |
| **Performance**            | Good                     | Good                    | Good with snapshots      | Excellent                | Excellent                          |
| **Learning Curve**         | Low                      | Low-Medium              | Medium                   | High                     | Very Low                           |
| **Enterprise Features**    | Yes                      | Yes                     | Yes                      | Yes                      | Basic                              |
| **Error Handling**         | Exception-based          | Exception-based         | Exception-based          | Functional Result types  | Exception-based                    |
| **Functional Programming** | No                       | No                      | Yes                      | Yes                      | Yes                                |

### When to Use Each Pattern

**🎯 Use Modern AggregateRoot when:**
- You're new to event sourcing and want to start with familiar patterns
- Your domain logic is straightforward and doesn't require complex state management
- You prefer object-oriented programming approaches
- You want automatic change tracking and good IDE support
- You need good integration with Spring Boot and dependency injection

**🎯 Use WithState Pattern when:**
- Your aggregate state is complex and you want to separate it from business logic
- You need to test state transitions independently from business logic
- You want better maintainability for complex aggregates
- You're building large aggregates with many fields and complex event handlers

**🎯 Use FlexAggregate when:**
- You prefer functional programming patterns
- You want explicit control over state transitions
- You're comfortable with immutable data structures
- You need high performance with proper snapshot configuration
- You want to avoid hidden state mutations

**🎯 Use Traditional Decider when:**
- You need sophisticated error handling with result types
- You're building enterprise-grade systems with complex requirements
- You want tight integration with event store optimizations
- You need advanced features like snapshots and performance tuning
- You're experienced with functional programming and event sourcing

**🎯 Use EventStreamDecider when:**
- You're new to event sourcing and want to learn the fundamentals
- Your domain logic is simple and doesn't require complex error handling
- You prefer working directly with event streams
- You want easy-to-test, pure functions
- You're building prototypes or simple applications
- You value simplicity over advanced features

## EventStreamDecider Pattern (Simplified Event Sourcing)

⚠️ NOTE: API is experimental and subject to change!

**Core Interface:** `dk.trustworks.essentials.components.eventsourced.aggregates.eventstream.EventStreamDecider`

The `EventStreamDecider` provides a simplified approach to event sourcing that focuses on processing commands against event streams to produce new events.  
It operates directly on event streams rather than managing explicit state, making it more functional and easier to reason about.

**Event Modeling, Slicing and the Open/Closed principle**

The `EventStreamDecider` pattern is perfect for **Event Modeling** and its **slicing implementation approach**.
This pattern naturally supports the **Open/Closed Principle** by ensuring that **only events are shared across slices** -
each slice can independently evolve its command handling logic without affecting other slices, as long as the event contracts remain stable.

**What makes this pattern ideal for slicing:**
- **Localized Changes**: Modifications are typically confined to a single slice at a time.
  - When you need to add new behavior or modify existing business rules, you create a new `EventStreamDecider` implementation or modify an existing one without touching other slices.
- **Independent Evolution**: Each command slice (represented by an `EventStreamDecider`) can evolve independently.
  - A slice that handles order creation doesn't need to know about order shipping logic - they only share the events that represent state changes.
- **Contract Stability**: The event contracts act as the stable interface between slices.
  - As long as events maintain backward compatibility, different slices can be developed, deployed, and modified by different teams at different cadences.
- **Single Responsibility**: Each `EventStreamDecider` has a focused responsibility - it handles one specific command type against the event stream. This makes the code easier to understand, test, and maintain.

This approach is particularly powerful for teams adopting Event Modeling where business processes are broken down into slices that can be implemented incrementally.   
Each command handling slice becomes a self-contained `EventStreamDecider` that processes its specific commands while participating in the larger event-driven system through shared events.

For developers new to this concept, think of it as microservices within a single aggregate boundary - each slice handles its own concerns but coordinates through events rather than direct calls.

**Key Characteristics:**
- **Event-Centric**: Works directly with event streams rather than maintaining state
- **Functional**: Pure functions that given the same input always produce the same output
- **Idempotent**: Can safely be called multiple times with the same input
- **Stateless**: No internal state management - state is derived from events
- **Simple**: Focused on the core decider pattern without complex infrastructure, ideal for a slicing approach to implementation

```java
// EventStreamDecider for creating orders
public class CreateOrderDecider implements EventStreamDecider<CreateOrder, OrderEvent> {
    
    @Override
    public Optional<OrderEvent> handle(CreateOrder command, List<OrderEvent> events) {
        requireNonNull(command, "command cannot be null");
        requireNonNull(events, "events cannot be null");
        
        // Check if order already exists by looking at events
        boolean orderExists = events.stream()
            .anyMatch(event -> event instanceof OrderCreated);
        
        if (orderExists) {
            return Optional.empty(); // Idempotent - order already created
        }
        
        // Create new order
        return Optional.of(new OrderCreated(command.orderId(), command.customerId()));
    }
    
    @Override
    public boolean canHandle(Class<?> command) {
        return CreateOrder.class.isAssignableFrom(command);
    }
}

// EventStreamDecider for confirming orders
public class ConfirmOrderDecider implements EventStreamDecider<ConfirmOrder, OrderEvent> {
    
    private final ConfirmOrderStateEvolver evolver = new ConfirmOrderStateEvolver();
    
    @Override
    public Optional<OrderEvent> handle(ConfirmOrder command, List<OrderEvent> events) {
        requireNonNull(command, "command cannot be null");
        requireNonNull(events, "events cannot be null");
        
        // Rebuild current state from events
        var currentState = EventStreamEvolver.applyEvents(evolver, events);
        
        if (currentState.isEmpty()) {
            throw new IllegalStateException("Cannot confirm order that does not exist");
        }
        
        var state = currentState.get();
        
        if (!state.canBeConfirmed()) {
            if (state.status() == OrderStatus.CONFIRMED) {
                // Already confirmed - idempotent behavior
                return Optional.empty();
            }
            throw new IllegalStateException("Cannot confirm order in status: " + state.status());
        }
        
        return Optional.of(new OrderConfirmed(command.orderId()));
    }
    
    @Override
    public boolean canHandle(Class<?> command) {
        return ConfirmOrder.class.isAssignableFrom(command);
    }
}

// EventStreamEvolver for rebuilding state from events (only used by ConfirmOrderDecider to maintain the Open/Closed Principle and reduce coupling between slices)
public class ConfirmOrderStateEvolver implements EventStreamEvolver<OrderEvent, OrderState> {
    
    @Override
    public Optional<ConfirmOrderState> applyEvent(OrderEvent event, Optional<ConfirmOrderState> currentState) {
        requireNonNull(event, "event cannot be null");
        requireNonNull(currentState, "currentState cannot be null");
        
        return switch (event) {
            case OrderCreated created -> Optional.of(
                    ConfirmOrderState.created(created.orderId(), created.customerId())
            );
            case OrderConfirmed confirmed -> currentState.map(state -> 
                state.withConfirmed()
            );
            case OrderShipped shipped -> currentState.map(state -> 
                state.withShipped()
            );
            case OrderCancelled cancelled -> currentState.map(state -> 
                state.withCancelled(cancelled.reason())
            );
            default -> currentState; // Unknown event types are ignored
        };
    }
}

/**
 * Immutable state representation of an order (shouldn't be shared across Deciders to maintain the Open/Close principle)
 */
public record ConfirmOrderState(
        OrderId orderId,
        CustomerId customerId,
        OrderStatus status,
        Instant createdAt,
        Instant confirmedAt,
        Instant shippedAt,
        Instant cancelledAt,
        String cancellationReason
) {

   public static ConfirmOrderState created(OrderId orderId, CustomerId customerId) {
      return new ConfirmOrderState(orderId, customerId, OrderStatus.PENDING, null, null, null, null, null);
   }

   public OrderState withConfirmed() {
      return new ConfirmOrderState(orderId, customerId, OrderStatus.CONFIRMED, createdAt, null, shippedAt, cancelledAt, cancellationReason);
   }

   public ConfirmOrderState withShipped() {
      return new ConfirmOrderState(orderId, customerId, OrderStatus.SHIPPED, createdAt, confirmedAt, null, cancelledAt, cancellationReason);
   }

   public ConfirmOrderState withCancelled(String reason) {
      return new ConfirmOrderState(orderId, customerId, OrderStatus.CANCELLED, createdAt, confirmedAt, shippedAt, null, reason);
   }

   public boolean canBeConfirmed() {
      return status == OrderStatus.PENDING;
   }

   public boolean canBeShipped() {
      return status == OrderStatus.CONFIRMED;
   }

   public boolean canBeCancelled() {
      return status == OrderStatus.PENDING || status == OrderStatus.CONFIRMED;
   }
}
```

**Integration with Event Store:**
`EventStreamDecider`'s can be integrated with the event store infrastructure using `EventStreamDeciderCommandHandlerAdapter` which handles the loading of event streams, command routing, and event persistence.  
The `EventStreamDeciderAndAggregateTypeConfigurator` provides automatic configuration `EventStreamDeciderCommandHandlerAdapter` based on `EventStreamAggregateTypeConfiguration` and `EventStreamDecider` instances.

**`EventStreamAggregateTypeConfiguration` Parameters:**
- **AggregateType**: The logical name for the aggregate (e.g., "Orders")
- **Aggregate ID Class**: The type of the aggregate identifier (e.g., OrderId.class)
- **Serializer**: How to serialize/deserialize aggregate IDs to/from String values
- **Support Checker**: Determines which deciders handle which commands
- **Command ID Extractor**: Function to extract aggregate ID from commands
- **Event ID Extractor**: Function to extract aggregate ID from events

```java
// Spring Boot Configuration
@Configuration
public class DomainConfiguration {
    
    @Bean
    public EventStreamDeciderAndAggregateTypeConfigurator eventStreamDeciderConfigurator(
            ConfigurableEventStore<?> eventStore,
            CommandBus commandBus,
            List<EventStreamAggregateTypeConfiguration> aggregateTypeConfigurations,
            List<EventStreamDecider<?, ?>> deciders) {
        return new EventStreamDeciderAndAggregateTypeConfigurator(
            eventStore, 
            commandBus, 
            aggregateTypeConfigurations, 
            deciders
        );
    }
    
    @Bean
    public EventStreamAggregateTypeConfiguration orderAggregateConfiguration() {
        return new EventStreamAggregateTypeConfiguration(
            AggregateType.of("Orders"),
            OrderId.class,
            AggregateIdSerializer.serializerFor(OrderId.class),
            new EventStreamDeciderSupportsAggregateTypeChecker.HandlesCommandsThatInheritFromCommandType(OrderCommand.class),
            command -> ((OrderCommand) command).orderId(),
            event -> ((OrderEvent) event).orderId()
        );
    }
    
    // Define your deciders as beans (or annotate them with @Component or @Service)
    @Bean
    public CreateOrderDecider createOrderDecider() {
        return new CreateOrderDecider();
    }
    
    @Bean
    public ConfirmOrderDecider confirmOrderDecider() {
        return new ConfirmOrderDecider();
    }
    
    @Bean
    public ShipOrderDecider shipOrderDecider() {
        return new ShipOrderDecider();
    }
}

// Manual Configuration (without Spring)
var configurator = new EventStreamDeciderAndAggregateTypeConfigurator(
    eventStore,
    commandBus,
    List.of(orderConfiguration, customerConfiguration),
    List.of(
        new CreateOrderDecider(),
        new ConfirmOrderDecider(),
        new ShipOrderDecider(),
        new CreateCustomerDecider()
    )
);
```

**Testing Support:**
`EventStreamDecider`'s can be easily tested using the `GivenWhenThenScenario` testing framework:

```java
@Test
void shouldCreateOrderWhenNoExistingOrder() {
    var scenario = new GivenWhenThenScenario<>(new CreateOrderDecider());
    
    var orderId = OrderId.random();
    var customerId = CustomerId.random();
    
    scenario
        .given() // No existing events
        .when(new CreateOrder(orderId, customerId))
        .then(new OrderCreated(orderId, customerId));
}

@Test
void shouldNotCreateOrderWhenOrderAlreadyExists() {
    var scenario = new GivenWhenThenScenario<>(new CreateOrderDecider());
    
    var orderId = OrderId.random();
    var customerId = CustomerId.random();
    
    scenario
        .given(new OrderCreated(orderId, customerId))
        .when(new CreateOrder(orderId, customerId))
        .thenExpectNoEvent(); // Idempotent behavior
}
```

**When to Use EventStreamDecider:**
- **Simple Command Processing**: When you need straightforward command-to-event mapping
- **Functional Approach**: When you prefer functional programming patterns
- **Stateless Operations**: When `EventStreamEvolver` is sufficient, and you don't need to maintain complex internal state
- **Testing Focus**: When you want easily testable decider logic
- **Event-Driven Design**: When your domain naturally thinks in terms of event streams

## Persisting a Stateful Aggregate
Flow showing the internal processing for persisting a new Aggregate instance:
```
var unitOfWork = unitOfWorkFactory.getOrCreateNewUnitOfWork();
var order = new Order(orderId, customerId, orderNumber);
order.addProduct(productId, productQuantity);
ordersRepository.save(order);
unitOfWork.commit();
```
![Persisting an Aggregate](images/persist-aggregate.png)

### Modern stateful Order aggregate with a separate state object

See `eventsourced-aggregates/src/test/java/dk/trustworks/essentials/components/eventsourced/aggregates/modern/OrderAggregateRootRepositoryTest.java`
for more details.

```
public class Order extends AggregateRoot<OrderId, OrderEvent, Order> implements WithState<OrderId, OrderEvent, Order, OrderState> {
    /**
     * Used for rehydration
     */
    public Order(OrderId orderId) {
        super(orderId);
    }

    public Order(OrderId orderId,
                 CustomerId orderingCustomerId,
                 int orderNumber) {
        super(orderId);
        requireNonNull(orderingCustomerId, "You must provide an orderingCustomerId");

        apply(new OrderEvent.OrderAdded(orderId,
                                        orderingCustomerId,
                                        orderNumber));
    }

    public void addProduct(ProductId productId, int quantity) {
        requireNonNull(productId, "You must provide a productId");
        if (state().accepted) {
            throw new IllegalStateException("Order is already accepted");
        }
        apply(new OrderEvent.ProductAddedToOrder(aggregateId(),
                                                 productId,
                                                 quantity));
    }

    public void adjustProductQuantity(ProductId productId, int newQuantity) {
        requireNonNull(productId, "You must provide a productId");
        if (state().accepted) {
            throw new IllegalStateException("Order is already accepted");
        }
        if (state().productAndQuantity.containsKey(productId)) {
            apply(new OrderEvent.ProductOrderQuantityAdjusted(aggregateId(),
                                                              productId,
                                                              newQuantity));
        }
    }

    public void removeProduct(ProductId productId) {
        requireNonNull(productId, "You must provide a productId");
        if (state().accepted) {
            throw new IllegalStateException("Order is already accepted");
        }
        if (state().productAndQuantity.containsKey(productId)) {
            apply(new OrderEvent.ProductRemovedFromOrder(aggregateId(),
                                                         productId));
        }
    }

    public void accept() {
        if (state().accepted) {
            return;
        }
        // Apply the event together with its event order (in case this is needed)
        apply(eventOrder -> new OrderEvent.OrderAccepted(aggregateId(),
                                                         eventOrder));
    }

    /**
     * Covariant return type overriding.<br>
     * This will allow the {@link AggregateRoot#state()} method to return
     * the specific state type, which means we don't need to use e.g. <code>state(OrderState.class).accepted</code><br>
     */
    @SuppressWarnings("unchecked")
    protected OrderState state() {
        return super.state();
    }
}
```

##### Order Events

```
public class OrderEvent {
    public final OrderId orderId;

    public OrderEvent(OrderId orderId) {
        this.orderId = requireNonNull(orderId);
    }

    public static class OrderAdded extends OrderEvent {
        public final CustomerId orderingCustomerId;
        public final long       orderNumber;

        public OrderAdded(OrderId orderId, CustomerId orderingCustomerId, long orderNumber) {
            super(orderId);
            this.orderingCustomerId = orderingCustomerId;
            this.orderNumber = orderNumber;
        }
    }

    public static class OrderAccepted extends OrderEvent {
        public final EventOrder eventOrder;

        public OrderAccepted(OrderId orderId, EventOrder eventOrder) {
            super(orderId);
            this.eventOrder = eventOrder;
        }
    }

    public static class ProductAddedToOrder extends OrderEvent {
        public final ProductId productId;
        public final int       quantity;

        public ProductAddedToOrder(OrderId orderId, ProductId productId, int quantity) {
            super(orderId);
            this.productId = productId;
            this.quantity = quantity;
        }
    }

    public static class ProductOrderQuantityAdjusted extends OrderEvent {
        public final ProductId productId;
        public final int       newQuantity;

        public ProductOrderQuantityAdjusted(OrderId orderId, ProductId productId, int newQuantity) {
            super(orderId);
            this.productId = productId;
            this.newQuantity = newQuantity;
        }
    }

    public static class ProductRemovedFromOrder extends OrderEvent {
        public final ProductId productId;

        public ProductRemovedFromOrder(OrderId orderId, ProductId productId) {
            super(orderId);
            this.productId = productId;
        }
    }
}
```

##### Modern Order State

```
public class OrderState extends AggregateState<OrderId, OrderEvent, Order> {
     Map<ProductId, Integer> productAndQuantity;
     boolean                 accepted;

    @EventHandler
    private void on(OrderEvent.OrderAdded e) {
        productAndQuantity = new HashMap<>();
    }

    @EventHandler
    private void on(OrderEvent.ProductAddedToOrder e) {
        var existingQuantity = productAndQuantity.get(e.productId);
        productAndQuantity.put(e.productId, e.quantity + (existingQuantity != null ? existingQuantity : 0));
    }

    @EventHandler
    private void on(OrderEvent.ProductOrderQuantityAdjusted e) {
        productAndQuantity.put(e.productId, e.newQuantity);
    }

    @EventHandler
    private void on(OrderEvent.ProductRemovedFromOrder e) {
        productAndQuantity.remove(e.productId);
    }

    @EventHandler
    private void on(OrderEvent.OrderAccepted e) {
        accepted = true;
    }
}
```

#### Modern stateful Order Aggregate without separate state object

```
public class Order extends AggregateRoot<OrderId, OrderEvent, Order> {
    private Map<ProductId, Integer> productAndQuantity;
    private boolean                 accepted;

    /**
     * Used for Aggregate Snapshot deserialization
     */
    public Order() {}

    /**
     * Used for rehydration
     */
    public Order(OrderId orderId) {
        super(orderId);
    }

    public Order(OrderId orderId,
                 CustomerId orderingCustomerId,
                 int orderNumber) {
        this(orderId);
        requireNonNull(orderingCustomerId, "You must provide an orderingCustomerId");

        apply(new OrderEvent.OrderAdded(orderId,
                                        orderingCustomerId,
                                        orderNumber));
    }

    public void addProduct(ProductId productId, int quantity) {
        requireNonNull(productId, "You must provide a productId");
        if (accepted) {
            throw new IllegalStateException("Order is already accepted");
        }
        apply(new OrderEvent.ProductAddedToOrder(aggregateId(),
                                                 productId,
                                                 quantity));
    }

    public void adjustProductQuantity(ProductId productId, int newQuantity) {
        requireNonNull(productId, "You must provide a productId");
        if (accepted) {
            throw new IllegalStateException("Order is already accepted");
        }
        if (productAndQuantity.containsKey(productId)) {
            apply(new OrderEvent.ProductOrderQuantityAdjusted(aggregateId(),
                                                              productId,
                                                              newQuantity));
        }
    }

    public void removeProduct(ProductId productId) {
        requireNonNull(productId, "You must provide a productId");
        if (accepted) {
            throw new IllegalStateException("Order is already accepted");
        }
        if (productAndQuantity.containsKey(productId)) {
            apply(new OrderEvent.ProductRemovedFromOrder(aggregateId(),
                                                         productId));
        }
    }

    public void accept() {
        if (accepted) {
            return;
        }
        apply(eventOrder -> new OrderEvent.OrderAccepted(aggregateId(),
                                                         eventOrder));
    }

    @EventHandler
    private void on(OrderEvent.OrderAdded e) {
        productAndQuantity = new HashMap<>();
    }

    @EventHandler
    private void on(OrderEvent.ProductAddedToOrder e) {
        var existingQuantity = productAndQuantity.get(e.productId);
        productAndQuantity.put(e.productId, e.quantity + (existingQuantity != null ? existingQuantity : 0));
    }

    @EventHandler
    private void on(OrderEvent.ProductOrderQuantityAdjusted e) {
        productAndQuantity.put(e.productId, e.newQuantity);
    }

    @EventHandler
    private void on(OrderEvent.ProductRemovedFromOrder e) {
        productAndQuantity.remove(e.productId);
    }

    @EventHandler
    private void on(OrderEvent.OrderAccepted e) {
        accepted = true;
    }
}
```
For other examples see:

#### Modern `AggregateRoot`

- With separate `WithState` object using `ReflectionBasedAggregateInstanceFactory`:
    - `eventsourced-aggregates/src/test/java/dk/trustworks/essentials/components/eventsourced/aggregates/modern/with_state/OrderAggregateRootWithStateRepositoryIT.java`
- **Without** separate State object using `ReflectionBasedAggregateInstanceFactory`:
    - `eventsourced-aggregates/src/test/java/dk/trustworks/essentials/components/eventsourced/aggregates/modern/OrderAggregateRootRepositoryIT.java`

#### Functional `FlexAggregate`

- `eventsourced-aggregates/src/test/java/dk/trustworks/essentials/components/eventsourced/aggregates/flex/FlexAggregateRepositoryIT.java`

#### Classic `AggregateRoot`

- Using `ObjenesisAggregateInstanceFactory`:
    - `eventsourced-aggregates/src/test/java/dk/trustworks/essentials/components/eventsourced/aggregates/classic/objenesis/OrderAggregateRootRepositoryIT.java`
- Using `ReflectionBasedAggregateInstanceFactory`:
    - `eventsourced-aggregates/src/test/java/dk/trustworks/essentials/components/eventsourced/aggregates/classic/OrderAggregateRootRepositoryIT.java`

#### Classic `AggregateRootWithState`

- Using `ObjenesisAggregateInstanceFactory`:
    - `eventsourced-aggregates/src/test/java/dk/trustworks/essentials/components/eventsourced/aggregates/classic/objenesis/state/OrderWithStateAggregateRootRepositoryIT.java`
- Using `ReflectionBasedAggregateInstanceFactory`:
    - `eventsourced-aggregates/src/test/java/dk/trustworks/essentials/components/eventsourced/aggregates/classic/state/OrderWithStateAggregateRootRepositoryIT.java`

### AggregateType

Each Aggregate implementation class (such as the `Order` Aggregate above) needs to be associated with an `AggregateType`
.  
An `AggregateType` should not be confused with the Java implementation class for your Aggregate.

An `AggregateType` is used for grouping/categorizing multiple `AggregateEventStream` instances related to similar types
of aggregates.  
This allows us to easily retrieve or be notified of new Events related to the same type of Aggregates (such as when
using `EventStore#pollEvents(..)`)     
Using `SeparateTablePerAggregateTypePersistenceStrategy` means that each `AggregateType` will be persisted in a separate
event store table.

What's important here is that the AggregateType is only a name and shouldn't be confused with the Fully Qualified Class
Name of the Aggregate implementation class.  
This is the classical split between the logical concept and the physical implementation.  
It's important to not link the Aggregate Implementation Class (the Fully Qualified Class Name) with the AggregateType
name as that would make refactoring of your code base much harder, as the Fully
Qualified Class Name then would be captured in the stored Events.   
Had the AggregateType and the Aggregate Implementation Class been one and the same, then moving the Aggregate class to
another package or renaming it would break many things.

To avoid the temptation to use the same name for both the AggregateType and the Aggregate Implementation Class, we
prefer using the plural name of the Aggregate as the AggregateType name.  
Example:

| Aggregate-Type | Aggregate Root Implementation Class (Fully Qualified Class Name) | Top-level Event Type (Fully Qualified Class Name) |  
|----------------|------------------------------------------------------------------|---------------------------------------------------|
| Orders         | com.mycompany.project.persistence.Order                          | com.mycompany.project.persistence.OrderEvent      |
| Accounts       | com.mycompany.project.persistence.Account                        | com.mycompany.project.persistence.AccountEvent    |
| Customer       | com.mycompany.project.persistence.Customer                       | com.mycompany.project.persistence.CustomerEvent   |

You can add as many `AggregateType` configurations as needed, but they need to be added BEFORE you try to persist or
load events related to a given `AggregateType`.

### AggregateRoot Repository

To load and persist Aggregates you need an Aggregate Repository.

For the `FlexAggregate` you must acquire a `FlexAggregateRepository` instance using the static `from` method on the `FlexAggregateRepository` interface.

For `StatefulAggregate`'s you must acquire `StatefulAggregateRepository` instance for your Aggregate Root Implementation
Class,  using the static `from` method on the `StatefulAggregateRepository` interface.

Apart from providing an instance of the `EventStore` you also need to provide either an `AggregateTypeConfiguration`,
such as
the `SeparateTablePerAggregateTypeConfiguration` (which instructs the `EventStore`'s persistence strategy, such as
the `SeparateTablePerAggregateTypePersistenceStrategy`
how to map your Java Events into JSON in the Event Store) or use the default configuration provided with the
configured `AggregateEventStreamPersistenceStrategy`
(see the `PostgreSQL Event Store` section for details on configuring the `EventStore`)

```
var orders = AggregateType.of("Orders");
var ordersRepository = StatefulAggregateRepository.from(eventStore,
                                                    SeparateTablePerAggregateTypeConfiguration.standardSingleTenantConfiguration(
                                                        orders,
                                                        new JacksonJSONEventSerializer(createObjectMapper()),
                                                        AggregateIdSerializer.serializerFor(OrderId.class),
                                                        IdentifierColumnType.UUID,
                                                        JSONColumnType.JSONB),
                                                    StatefulAggregateInstanceFactory.reflectionBasedAggregateRootFactory(), // Alternative is StatefulAggregateInstanceFactory.objenesisAggregateRootFactory()
                                                    Order.class);
// or 
var ordersRepository = StatefulAggregateRepository.from(eventStore,
                                                        orders,
                                                        StatefulAggregateInstanceFactory.reflectionBasedAggregateRootFactory(),
                                                        Order.class);
                                                    

var orderId = OrderId.random();
unitOfWorkFactory.usingUnitOfWork(unitOfWork -> {                                                    
   var order = new Order(orderId, CustomerId.random(), 1234);
   order.addProduct(ProductId.random(), 2);
   ordersRepository.persist(order);
});

// Using Spring Transaction Template
var order = transactionTemplate.execute(status -> ordersRepository.load(orderId));
```

### Aggregate Snapshots
Sometimes we need to work with Aggregates that over time end up persisting a lot of events and where loading all Aggregate related Events from the `EventStore`
will incur too much overhead.

For such cases we can use the `AggregateSnapshotRepository` concept, which can be used together with e.g. the `StatefulAggregateRepository`:

```
var ordersRepository = StatefulAggregateRepository.from(eventStore,
                                                      ORDERS,
                                                      reflectionBasedAggregateRootFactory(),
                                                      Order.class,
                                                      snapshotRepository);
```
The `AggregateSnapshotRepository` supports persisting snapshots of Aggregates and these snapshots can be used when loading the Aggregate.
If an Account aggregate has 1000 events and the last snapshot persisted included 997 of these events, then loading the Account aggregate would entail:
-  Checking if we have an `AggregateSnapshot` for the specific Account Aggregate instance
- If there's an `AggregateSnapshot`, then we begin with loading this snapshot, which provides us with an Aggregate instance. 
- Afterwards we will load all Events (related to the same Aggregate instance) that have occurred since the `AggregateSnapshot` was persisted.
- All events returned (if any) will be rehydrated onto the Aggregate instance

When ever an Aggregate is added or updated, the `AggregateSnapshotRepository` will persist a new `AggregateSnapshot` according to the 
specified `AddNewAggregateSnapshotStrategy`. It will also delete any historic `AggregateSnapshot` according to the `AggregateSnapshotDeletionStrategy`.

### Persisting `AggregateSnapshot`'s
The `PostgresqlAggregateSnapshotRepository` is the only durable `AggregateSnapshotRepository`.

> Please see the **Security** section above for additional Security advices related to using the `PostgresqlAggregateSnapshotRepository`

It will create any new `AggregateSnapshot` in the same thread and transaction which added/changed the Aggregate instance.
This means that adding aggregate snapshots in the database (including any clean-ups) will effectively affect aggregate persistence performance.  
It's therefore advisable to combine `PostgresqlAggregateSnapshotRepository` with the `DelayedUpdateAggregateSnapshotDelegate`, which will directly delegates all operations to the provided <code>delegateRepository</code>,
except for `AggregateSnapshotRepository#aggregateUpdated(Object, AggregateEventStream)` and `AggregateSnapshotRepository#deleteSnapshots(AggregateType, Object, Class, List)`, which are performed **asynchronously** in the background.

```
var aggregateEventStreamConfigurationFactory = SeparateTablePerAggregateTypeEventStreamConfigurationFactory.standardSingleTenantConfiguration(new JacksonJSONEventSerializer(createObjectMapper()),
                                                                                                                                                          IdentifierColumnType.UUID,
                                                                                                                                                                  JSONColumnType.JSONB);
var snapshotRepository = new PostgresqlAggregateSnapshotRepository(eventStore,
                                                                   unitOfWorkFactory,
                                                                   aggregateEventStreamConfigurationFactory.jsonSerializer,
                                                                   AddNewAggregateSnapshotStrategy.updateWhenBehindByNumberOfEvents(2),
                                                                   AggregateSnapshotDeletionStrategy.keepALimitedNumberOfHistoricSnapshots(3));

ordersRepository = StatefulAggregateRepository.from(eventStore,
                                                    ORDERS,
                                                    reflectionBasedAggregateRootFactory(),
                                                    Order.class,
                                                    DelayedUpdateAggregateSnapshotDelegate.delegateTo(snapshotRepository));
```

#### AddNewAggregateSnapshotStrategy
The `AddNewAggregateSnapshotStrategy` specifies how often an `AggregateSnapshot` should be stored.  
Out of the box it supports:
- `AddNewAggregateSnapshotStrategy.updateWhenBehindByNumberOfEvents(numberOfEventsBetweenEachSnapshot)`
- `AddNewAggregateSnapshotStrategy.updateOnEachAggregateUpdate()`

#### AggregateSnapshotDeletionStrategy
The `AggregateSnapshotDeletionStrategy` controls which historic aggregate snapshots (i.e. old aggregate snapshots) should be deleted when a new aggregate snapshot is persisted
Out of the box it supports:
- `AggregateSnapshotDeletionStrategy.keepALimitedNumberOfHistoricSnapshots(numberOfHistoricSnapshotsToKeep)`
- `AggregateSnapshotDeletionStrategy.keepAllHistoricSnapshots()`
- `AggregateSnapshotDeletionStrategy.deleteAllHistoricSnapshots()`


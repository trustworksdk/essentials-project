/*
 * Copyright 2021-2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dk.trustworks.essentials.components.foundation.scheduler.pgcron;

import dk.trustworks.essentials.components.foundation.scheduler.*;
import dk.trustworks.essentials.components.foundation.transaction.jdbi.*;
import org.slf4j.*;

import java.time.OffsetDateTime;
import java.util.*;
import java.util.regex.Pattern;

import static dk.trustworks.essentials.components.foundation.scheduler.JobNameResolver.UNDER_SCORE;
import static dk.trustworks.essentials.shared.FailFast.requireNonNull;
import static dk.trustworks.essentials.shared.MessageFormatter.msg;

/**
 * Repository class for managing PostgreSQL cron jobs and their associated run details.
 * This class provides methods for scheduling, unscheduling, and retrieving cron job
 * information and run details.
 * <strong>Security Note:</strong><br>
 * <b>It is the responsibility of the user of this component to sanitize the {@link  PgCronJob#cronExpression()}, {@link  PgCronJob#functionName()} and  {@link  PgCronJob#sqlCommand()}
 * to ensure the security of all the SQL statements generated by this component.</b><br>
 * The {@link PgCronRepository} component will
 * validate {@link  PgCronJob#cronExpression()}, {@link  PgCronJob#functionName()} and  {@link  PgCronJob#sqlCommand()} as an initial layer of defense against SQL injection by applying naming conventions intended to reduce the risk of malicious input.<br>
 * However, Essentials components does not offer exhaustive protection, nor does it ensure the complete security of the resulting SQL against SQL injection threats.<br>
 * <b>The responsibility for implementing protective measures against SQL Injection lies exclusively with the users/developers using the Essentials components and its supporting classes.</b><br>
 * Users must ensure thorough sanitization and validation of API input parameters, column, table, and index names.<br>
 * Insufficient attention to these practices may leave the application vulnerable to SQL injection, potentially endangering the security and integrity of the database.<br>
 * <br>
 * It is highly recommended that the {@link PgCronJob#cronExpression()}, {@link PgCronJob#functionName()} and  {@link PgCronJob#sqlCommand()} value is only derived from a controlled and trusted source.<br>
 * To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the {@link PgCronJob#cronExpression()}, {@link  PgCronJob#functionName()} and  {@link PgCronJob#sqlCommand()} values.<br>
 */
public class PgCronRepository {

    public static final  Pattern ARG_PATTERN             = Pattern.compile(
            "^(?:'([^']|'')*'|[0-9]+(?:\\.[0-9]+)?|[A-Za-z_][A-Za-z0-9_]*)$"
                                                                          );
    private static final Logger  log                     = LoggerFactory.getLogger(PgCronRepository.class);
    private static final int     MAX_ARGS_COUNT          = 10;
    private static final int     MAX_ARG_LENGTH          = 256;

    private final HandleAwareUnitOfWorkFactory<? extends HandleAwareUnitOfWork> unitOfWorkFactory;

    public static final String PG_CRON_JOB_TABLE_NAME         = "cron.job";
    public static final String PG_CRON_JOB_DETAILS_TABLE_NAME = "cron.job_run_details";

    /**
     * Constructs a new instance of {@code PgCronRepository} with the given unit of work factory.
     *
     * @param unitOfWorkFactory the {@link HandleAwareUnitOfWorkFactory} responsible for creating
     *                          and maintaining units of work in a handle-aware context
     */
    public PgCronRepository(HandleAwareUnitOfWorkFactory<? extends HandleAwareUnitOfWork> unitOfWorkFactory) {
        this.unitOfWorkFactory = requireNonNull(unitOfWorkFactory, "unitOfWorkFactory cannot be null");
    }

    /**
     * Schedules a PostgreSQL cron job using the pg_cron extension. The job is defined by
     * the provided {@link PgCronJob}, which includes the cron expression and functionName name.
     * This method validates the functionName name, creates the necessary SQL query, and inserts
     * the scheduled job into the database. The ID of the scheduled job is then returned.
     * <p>
     * See class security note. To mitigate the risk of SQL injection attacks, external or untrusted inputs should never directly provide the {@code PgCronJob#cronExpression} and {@code PgCronJob#functionName} values
     *
     * @param job the {@link PgCronJob} representing the cron job to be scheduled, which includes
     *            the functionName name and cron expression; must not be null
     * @return the ID of the scheduled job as an {@code Integer}, or {@code null} if the scheduling fails
     * @throws IllegalArgumentException if the job contains invalid data, such as an illegal functionName name
     */
    public Integer schedule(PgCronJob job) {
        requireNonNull(job, "job cannot be null");
        log.debug("Schedule PgCronJob '{}'", job);

        String cronExpression = job.cronExpression().toString();
        String functionName   = job.functionName();
        String jobName        = JobNameResolver.resolve(job.name());

        if (!SqlIdentifierValidator.isValidFunctionName(functionName)) {
            throw new IllegalArgumentException(
                    String.format("Invalid function name '%s'. Must be a valid SQL identifier.", functionName)
            );
        }

        String innerQuery = buildAndValidateInnerQuery(functionName, job.sqlCommand());

        Integer existingId = doesJobExist(jobName);
        if (existingId != null) {
            log.debug("Cron job '%s' already exists with id %d", jobName, existingId);
            return existingId;
        }

        String sql = "SELECT cron.schedule(:name, :cron, :query)::int;";
        return unitOfWorkFactory.withUnitOfWork(uow ->
                                                        uow.handle()
                                                           .createQuery(sql)
                                                           .bind("name", jobName)
                                                           .bind("cron", cronExpression)
                                                           .bind("query", innerQuery)
                                                           .mapTo(Integer.class)
                                                           .findOne()
                                                           .orElse(null)
                                               );
    }

    /**
     * Builds and validates the inner SQL query for a pg_cron job, protecting against SQL injection.
     *
     * @param functionName  the name of the SQL function to call
     * @param commandArgs   a comma-separated list of arguments (literals or identifiers)
     * @return a fully-formed SQL query string like "SELECT fn(arg1,arg2);"
     * @throws IllegalArgumentException if any argument is invalid or limits are exceeded
     */
    private String buildAndValidateInnerQuery(String functionName, String commandArgs) {
        boolean hasArgs = commandArgs != null && !commandArgs.trim().isEmpty();
        String safeArgs = "";

        if (hasArgs) {
            String[] parts = commandArgs.trim().split("\\s*,\\s*");
            if (parts.length > MAX_ARGS_COUNT) {
                throw new IllegalArgumentException(
                        String.format("Too many arguments (%d), max is %d", parts.length, MAX_ARGS_COUNT)
                );
            }

            for (String arg : parts) {
                if (arg.length() > MAX_ARG_LENGTH) {
                    throw new IllegalArgumentException(
                            String.format("Argument too long (%d chars), max is %d", arg.length(), MAX_ARG_LENGTH)
                    );
                }
                if (!ARG_PATTERN.matcher(arg).matches()) {
                    throw new IllegalArgumentException(
                            String.format("Invalid argument syntax: '%s'", arg)
                    );
                }
            }

            safeArgs = String.join(",", parts);
        }

        return hasArgs
               ? String.format("SELECT %s(%s);", functionName, safeArgs)
               : String.format("SELECT %s();", functionName);
    }

    /**
     * Checks whether a job exists in the database with the specified job name
     *
     * @param name@return the ID of the existing job as an {@code Integer}, or {@code null} if no matching job is found
     */
    public Integer doesJobExist(String name) {
        requireNonNull(name, "name cannot be null");
        var jobName = JobNameResolver.resolve(name);
        return unitOfWorkFactory.withUnitOfWork(uow -> {
            return uow.handle()
                              .createQuery("SELECT jobid FROM cron.job WHERE jobname = :name")
                              .bind("name", jobName)
                              .mapTo(Integer.class)
                              .findOne()
                              .orElse(null);

        });
    }

    /**
     * Deletes jobs in the database whose names end with the specified instance ID.
     * This is achieved by performing a SQL delete operation on the job table.
     *
     * @param instanceId the instance ID that is appended to the job name; only jobs with names ending in this instance ID will be deleted
     */
    public void deleteJobByNameEndingWithInstanceId(String instanceId) {
        unitOfWorkFactory.usingUnitOfWork(uow -> {
            int numberOfDeletedJobs = uow.handle()
                           .createUpdate("DELETE FROM cron.job WHERE jobname LIKE '%' ||  :instanceid")
                           .bind("instanceid", UNDER_SCORE + instanceId)
                           .execute();
            log.debug("Deleted {} PgCronJob(s) with name ending with '{}'", numberOfDeletedJobs, instanceId);
        });
    }

    /**
     * Unschedules a PostgreSQL cron job using the pg_cron extension. This method removes
     * the scheduled job from the database based on the job identifier provided.
     *
     * @param jobId the identifier of the pg_cron job to be unscheduled
     */
    public void unschedule(Integer jobId) {
        requireNonNull(jobId, "jobId cannot be null");
        log.debug("Unscheduling PgCronJob with id '{}'", jobId);
        String sql = "SELECT cron.unschedule(:jobId);";
        unitOfWorkFactory.usingUnitOfWork(uow -> {
            uow.handle()
               .createUpdate(sql)
               .bind("jobId", jobId)
               .execute();
            log.debug("Unscheduled PgCronJob with id '{}'", jobId);
        });
    }

    /**
     * Retrieves a paginated list of PostgreSQL cron entries from the database.
     * This method queries the {@code PG_CRON_JOB_TABLE_NAME} table using the
     * provided start index and page size to limit and offset the results.
     *
     * @param startIndex the starting index for pagination, specifying the offset at which to begin retrieving entries
     * @param pageSize   the maximum number of entries to retrieve in the result set
     * @return a list of {@link PgCronEntry} representing the retrieved PostgreSQL cron entries
     */
    public List<PgCronEntry> fetchPgCronEntries(long startIndex, long pageSize) {
        return unitOfWorkFactory.withUnitOfWork(uow -> {
            var sql = "SELECT * FROM cron.job LIMIT :limit OFFSET :offset";
            return uow.handle().createQuery(sql)
                      .bind("limit", pageSize)
                      .bind("offset", startIndex)
                      .map((rs, ctx) -> {
                          return new PgCronEntry(
                                  rs.getInt("jobid"),
                                  rs.getString("schedule"),
                                  rs.getString("command"),
                                  rs.getString("nodename"),
                                  rs.getInt("nodeport"),
                                  rs.getString("database"),
                                  rs.getBoolean("active"),
                                  rs.getString("jobname")
                          );
                      })
                      .collectIntoList();
        });
    }

    /**
     * Retrieves the total number of entries in the PostgreSQL cron job table.
     *
     * @return the count of entries in the {@code PG_CRON_JOB_TABLE_NAME} table as a {@code long}
     */
    public long getTotalPgCronEntries() {
        return unitOfWorkFactory.withUnitOfWork(uow -> {
            var sql = "SELECT COUNT(*) FROM cron.job";
            return uow.handle().createQuery(sql)
                      .mapTo(Long.class)
                      .one();
        });
    }

    /**
     * Retrieves a paginated list of PostgreSQL cron job run details for a specific job ID.
     * The results are fetched from the database based on the provided job ID, start index, and page size.
     *
     * @param jobId      the identifier of the PostgreSQL cron job; must not be null
     * @param startIndex the starting index for pagination, specifying the offset at which to begin retrieving entries
     * @param pageSize   the maximum number of entries to retrieve in the result set
     * @return a list of {@link PgCronJobRunDetails} representing the details of the cron job runs
     */
    public List<PgCronJobRunDetails> fetchPgCronJobDetails(Integer jobId, long startIndex, long pageSize) {
        requireNonNull(jobId, "jobId cannot be null");
        return unitOfWorkFactory.withUnitOfWork(uow -> {
            var sql = "SELECT * FROM cron.job_run_details WHERE jobid = :jobId LIMIT :limit OFFSET :offset";
            return uow.handle().createQuery(sql)
                      .bind("jobId", jobId)
                      .bind("limit", pageSize)
                      .bind("offset", startIndex)
                      .map((rs, ctx) -> {
                          return new PgCronJobRunDetails(
                                  rs.getInt("jobid"),
                                  rs.getInt("runid"),
                                  rs.getInt("job_pid"),
                                  rs.getString("database"),
                                  rs.getString("username"),
                                  rs.getString("command"),
                                  rs.getString("status"),
                                  rs.getString("return_message"),
                                  rs.getObject("start_time", OffsetDateTime.class),
                                  rs.getObject("end_time", OffsetDateTime.class)
                          );
                      })
                      .collectIntoList();
        });
    }

    /**
     * Retrieves the total count of PostgreSQL cron job run details for a specific job ID
     * from the database.
     *
     * @param jobId the identifier of the PostgreSQL cron job; must not be null
     * @return the total count of job run details as a {@code long}
     * @throws IllegalArgumentException if {@code jobId} is null
     */
    public long getTotalPgCronJobDetails(Integer jobId) {
        requireNonNull(jobId, "jobId cannot be null");
        return unitOfWorkFactory.withUnitOfWork(uow -> {
            var sql = "SELECT COUNT(*) FROM cron.job_run_details WHERE jobid = :jobid";
            return uow.handle().createQuery(sql)
                      .bind("jobid", jobId)
                      .mapTo(Long.class)
                      .one();
        });
    }

    /**
     * Represents a single entry in the PostgreSQL cron job table, scheduled using the pg_cron extension.
     * This immutable record encapsulates the details of a scheduled job, including its schedule,
     * the command to be executed, associated node information, database, status, and job name.
     *
     * @param jobId    the unique identifier assigned to the scheduled cron job
     * @param schedule the cron expression defining the execution schedule for the job
     * @param command  the command or functionName to be executed as part of the cron job
     * @param nodeName the name of the node on which the job is scheduled to run, if applicable
     * @param nodePort the port number of the node associated with the job
     * @param database the database context in which the cron job is executed
     * @param active   a flag indicating whether the cron job is currently active
     * @param jobName  the name of the cron job, used for identification and organization
     */
    public record PgCronEntry(Integer jobId, String schedule, String command, String nodeName, Integer nodePort, String database, boolean active, String jobName) {
    }

    /**
     * Represents the details of a PostgreSQL cron job run as retrieved from the pg_cron extension.
     * This record is primarily used for storing and transferring information regarding individual
     * executions of a PostgreSQL cron job, including metadata such as job identifiers, execution timings,
     * and execution status.
     *
     * @param jobId         the identifier of the cron job
     * @param runId         the unique identifier of the job's execution instance
     * @param jobPid        the process ID of the job during execution
     * @param database      the name of the database in which the job was executed
     * @param username      the username under which the cron job was executed
     * @param command       the command executed as part of the cron job
     * @param status        the execution status of the job (e.g., 'success' or 'failure')
     * @param returnMessage a message or output returned by the job execution
     * @param startTime     the timestamp indicating when the job execution started
     * @param endTime       the timestamp indicating when the job execution ended
     */
    public record PgCronJobRunDetails(Integer jobId, Integer runId, Integer jobPid, String database, String username, String command, String status, String returnMessage, OffsetDateTime startTime, OffsetDateTime endTime) {
    }
}
